/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CCALParser.jj */
/*@egen*//* Section 1 : Options */
options {
    JAVA_UNICODE_ESCAPE = true;
    IGNORE_CASE = true;
    
                 
                   
                             
                     
}

/* Section 2 : User Code */

PARSER_BEGIN(CCALParser)
import java.io.*;

    public class CCALParser/*@bgen(jjtree)*/implements CCALParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTCCALParserState jjtree = new JJTCCALParserState();

/*@egen*/
    
        public static SymbolTable symbolTable = new SymbolTable();
        // unless changed elsewhere scope is global
        public static String scope = "global";
        
        public static void main(String [] args) {
        CCALParser parser;

        if(args.length == 0) {
            System.out.println("CCAL Parser: Reading from standard input...");
            parser = new CCALParser(System.in);
        }

        else if(args.length == 1) {
            System.out.println("CCAL Parser: Reading from file " + args[0] + " ...");

            try {
                parser = new CCALParser(new java.io.FileInputStream(args[0]));
            }

            catch(java.io.FileNotFoundException e) {
                System.out.println("CCAL Parser: File " + args[0] + " not found");
                return;
            }
        }

        else {
            System.out.println("CCAL Parser: Usage is one of: ");
            System.out.println("             java CCALParser < inputfile");
            System.out.println("OR");
            System.out.println("             java CCALParser inputfile");
            return;
        }

        try {
            // Print AST
            System.out.println("ABSTRACT SYNTAX TREE");
            SimpleNode root = parser.Prog();
            root.dump("");
            System.out.println();
            
            // Print Symbol Table
            System.out.println("SYMBOL TABLE");            
            symbolTable.printSymbolTable();
            
            System.out.println();
            // Semantic Analysis
            SemanticAnalyser semanticAnalyser = new SemanticAnalyser();
            root.jjtAccept(semanticAnalyser, symbolTable);
            
            // 3 Address Code
           
            //FileWriter fw = new FileWriter();
            String filename = args[0].substring(0, args[0].lastIndexOf(".")) + ".ir";
            try {
                PrintStream out = new PrintStream(new FileOutputStream(filename)); 
                System.setOut(out);
                }
            catch (FileNotFoundException e) {
                e.printStackTrace();
            }
            CodeGenerator codeGenerator = new CodeGenerator();
            root.jjtAccept(codeGenerator, null);
        }

        catch(ParseException e) {
            System.out.println(e.getMessage());
            System.out.println("CCAL Parser: Encountered erros during parse.");
        }
    }
}
PARSER_END(CCALParser)

/* Section 3: Token Definitions */

TOKEN_MGR_DECLS :
{
    static int commentNesting = 0;
}

SKIP : /* ignoring spaces/tabs/newlines */
{
    " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"
}

/* COMMENTS */

SKIP :  /* Multi line comments */
{
    "/*" {
        commentNesting++;
    } : IN_COMMENT
}

<IN_COMMENT> SKIP :
{
    "/*" {
        commentNesting++;
    }
|   "*/" {
        commentNesting--;
        if(commentNesting == 0) {
            SwitchTo(DEFAULT);
        }
    }
|   <~[]>
}

SKIP : /* Single line comment */
{
    < "//" (~["\n"])* "\n" >
}

/* reserved words and punctuation */

TOKEN: {
    < VARIABLE: "var" >
    | < CONSTANT: "const" >
    | < RETURN: "return" >
    | < INTEGER: "integer" >
    | < BOOLEAN: "boolean" >
    | < VOID: "void" >
    | < MAIN: "main" >
    | < IF: "if" >
    | < ELSE: "else" >
    | < TRUE: "true" >
    | < FALSE: "false" >
    | < WHILE: "while" >
    | < BEGIN: "begin" >
    | < END: "end" >
    | < IS: "is" >
    | < SKP: "skip" >
}

/* tokens in the language */

TOKEN : {
  < LBRACKET: "(" >
| < RBRACKET: ")" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < COLON: ":" >
| < ASSIGNMENT: "=" >
| < MINUS: "-" >
| < PLUS: "+" >
| < TILDE: "~" >
| < OR: "||" >
| < AND: "&&" >
| < EQUALS: "==" >
| < NEQUALS: "!=" >
| < GT: ">" >
| < LT: "<" >
| < LE: "<=" >
| < GE: ">=" >
| < UNDERSCORE: "_" >
}

/* integers and identifiers */

/* a number can either be 0 or any combination of positive/negative numbers NOT starting with 0 */
/* an identifier must start with a letter and can be a combination of numbers and letters and underscores */

TOKEN: {
    <NUM : "0" | ((<MINUS>)? ["1" - "9"] (<DIGIT>)*) >
|   <#DIGIT: ["0"-"9"] >
|   <ID : <LETTER> (<LETTER> | <DIGIT> | <UNDERSCORE>)* >
|   <#LETTER: ["A"-"Z", "a"-"z"] >
}

/* anything not recognised so far */

TOKEN: {
    <OTHER : ~[] >
}

/* Section 4 : The grammar */

SimpleNode Prog()       : {/*@bgen(jjtree) Prog */
  Prog jjtn000 = new Prog(JJTPROG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Prog */
    try {
/*@egen*/
    DeclarationList() FunctionList() Main()/*@bgen(jjtree)*/
                                            {
                                              jjtree.closeNodeScope(jjtn000, true);
                                              jjtc000 = false;
                                            }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void DeclarationList() : {}
{
    (Declaration() <SEMICOLON> DeclarationList() | {})
}

void Declaration() : {}
{
    VariableDeclaration()
|   ConstantDeclaration()
}

void VariableDeclaration()         : {/*@bgen(jjtree) VarDec */
                                      VarDec jjtn000 = new VarDec(JJTVARDEC);
                                      boolean jjtc000 = true;
                                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String id; String type;}
{/*@bgen(jjtree) VarDec */
    try {
/*@egen*/
    t = <VARIABLE> id = Identifier() <COLON> type = Type()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.value = t.image;
        symbolTable.put(id, type, "var", scope);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

String Identifier()     : {/*@bgen(jjtree) Id */
                           Id jjtn000 = new Id(JJTID);
                           boolean jjtc000 = true;
                           jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;} 
{/*@bgen(jjtree) Id */
    try {
/*@egen*/
    t = <ID>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {jjtn000.value = t.image; return t.image; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ConstantDeclaration()           : {/*@bgen(jjtree) ConstDec */
                                        ConstDec jjtn000 = new ConstDec(JJTCONSTDEC);
                                        boolean jjtc000 = true;
                                        jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String id; String type;}
{/*@bgen(jjtree) ConstDec */
    try {
/*@egen*/
    t = <CONSTANT> id = Identifier() <COLON> type = Type() <ASSIGNMENT> Expression()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.value = t.image;
        symbolTable.put(id, type, "const", scope);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void FunctionList() : {}
{
    (Function() FunctionList() | {})
}

void Function()           : {/*@bgen(jjtree) Function */
                             Function jjtn000 = new Function(JJTFUNCTION);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String type; String id;}
{/*@bgen(jjtree) Function */
    try {
/*@egen*/
    (type = Type() id = Identifier() {symbolTable.put(id, type, "function", scope);
    
    if(!scope.equals("global")) {
        symbolTable.put(id, type, "function", "global");
        }
     scope = id;} <LBRACKET> ParameterList() <RBRACKET> <IS>
    DeclarationList()
    <BEGIN>
    StatementBlock()
    <RETURN> <LBRACKET> (Expression() | {}) <RBRACKET>/*@bgen(jjtree) Return */
                                                       {
                                                         Return jjtn001 = new Return(JJTRETURN);
                                                         boolean jjtc001 = true;
                                                         jjtree.openNodeScope(jjtn001);
                                                       }
                                                       try {
/*@egen*/ <SEMICOLON>/*@bgen(jjtree)*/
                                                       } finally {
                                                         if (jjtc001) {
                                                           jjtree.closeNodeScope(jjtn001, true);
                                                         }
                                                       }
/*@egen*/        
    <END>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
    // we have entered new scope here
    // scope of that function is still whatever scope it was previously
}

void FunctionReturn() : {Token t;}
{
    <RETURN> <LBRACKET> (Expression() | {}) <RBRACKET> <SEMICOLON> 
}

String Type()       : {/*@bgen(jjtree) Type */
                       Type jjtn000 = new Type(JJTTYPE);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    t = <INTEGER>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ {jjtn000.value = t.image; return t.image; }
|   t = <BOOLEAN>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/  {jjtn000.value = t.image; return t.image; }
|   t = <VOID>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/  {jjtn000.value = t.image; return t.image; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ParameterList()  : {}
{
    NonEmptyParameterList()
|   {}
}

void NonEmptyParameterList()                    : {/*@bgen(jjtree) #ParameterList(> 1) */
                                                   ParameterList jjtn000 = new ParameterList(JJTPARAMETERLIST);
                                                   boolean jjtc000 = true;
                                                   jjtree.openNodeScope(jjtn000);
/*@egen*/String id; String type;}
{/*@bgen(jjtree) #ParameterList(> 1) */
    try {
/*@egen*/
    id = Identifier() <COLON> type = Type() NonEmptyParameterList2()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
      jjtc000 = false;
    }
/*@egen*/ 
    { symbolTable.put(id, type, "param", scope);}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
      }
    }
/*@egen*/
}

void NonEmptyParameterList2() : {}
{
    <COMMA> NonEmptyParameterList()
|   {}
}

void Main()       : {/*@bgen(jjtree) Main */
  Main jjtn000 = new Main(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Main */
    try {
/*@egen*/
    {scope = "main";}(<MAIN>
    <BEGIN>
    DeclarationList()
    StatementBlock()
    <END>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void StatementBlock() : {}
{
    (Statement() StatementBlock())
|   {}
}

void Statement()            : {/*@bgen(jjtree) Statement */
                               Statement jjtn000 = new Statement(JJTSTATEMENT);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    Identifier() Statement2()
|   (<BEGIN> StatementBlock() <END>)
|   (t = <IF> Condition() <BEGIN> StatementBlock() <END> <ELSE> <BEGIN> StatementBlock() <END>/*@bgen(jjtree)*/
                                                                                               {
                                                                                                 jjtree.closeNodeScope(jjtn000, true);
                                                                                                 jjtc000 = false;
                                                                                               }
/*@egen*/ {jjtn000.value = t.image;} ) 
|   (t = <WHILE> Condition() <BEGIN> StatementBlock() <END>/*@bgen(jjtree)*/
                                                            {
                                                              jjtree.closeNodeScope(jjtn000, true);
                                                              jjtc000 = false;
                                                            }
/*@egen*/ {jjtn000.value = t.image;} ) 
|   (<SKP> <SEMICOLON>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/* took out the choice conflict here of <ID> */
void Statement2() : {Token t;}
{
    t = <ASSIGNMENT> Expression() <SEMICOLON>/*@bgen(jjtree) Assign */
                                              {
                                                Assign jjtn001 = new Assign(JJTASSIGN);
                                                boolean jjtc001 = true;
                                                jjtree.openNodeScope(jjtn001);
                                              }
                                              try {
/*@egen*//*@bgen(jjtree)*/
                                              {
                                                jjtree.closeNodeScope(jjtn001, true);
                                                jjtc001 = false;
                                              }
/*@egen*/ {jjtn001.value = t.image; }/*@bgen(jjtree)*/
                                              } finally {
                                                if (jjtc001) {
                                                  jjtree.closeNodeScope(jjtn001, true);
                                                }
                                              }
/*@egen*/        
|   t = <LBRACKET> ArgList() <RBRACKET>/*@bgen(jjtree) FuncAssign */
                                        {
                                          FuncAssign jjtn002 = new FuncAssign(JJTFUNCASSIGN);
                                          boolean jjtc002 = true;
                                          jjtree.openNodeScope(jjtn002);
                                        }
                                        try {
/*@egen*/ <SEMICOLON>/*@bgen(jjtree)*/
                                        } finally {
                                          if (jjtc002) {
                                            jjtree.closeNodeScope(jjtn002, true);
                                          }
                                        }
/*@egen*/            
|   {}
}

void Expression(): {}
{
    (Fragment() Fragment2()) 
|   (<LBRACKET> Expression() <RBRACKET> Fragment2()) 
}

void Fragment2() : {}
{
    BinaryOperator() Expression() 
|   {}
}


void BinaryOperator() : {Token t;}
{
    t = <PLUS>/*@bgen(jjtree) PlusOp */
               {
                 PlusOp jjtn001 = new PlusOp(JJTPLUSOP);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
               }
               try {
/*@egen*//*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn001, true);
                 jjtc001 = false;
               }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
               } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001, true);
                 }
               }
/*@egen*/        
|   t = <MINUS>/*@bgen(jjtree) MinusOp */
                {
                  MinusOp jjtn002 = new MinusOp(JJTMINUSOP);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn002, true);
                  jjtc002 = false;
                }
/*@egen*/ {jjtn002.value = t.image;}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002, true);
                  }
                }
/*@egen*/         
}

void Fragment() : {Token t;}
{
    <MINUS>/*@bgen(jjtree) MinusOp */
            {
              MinusOp jjtn001 = new MinusOp(JJTMINUSOP);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*/ Identifier()/*@bgen(jjtree)*/
            } catch (Throwable jjte001) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte001 instanceof RuntimeException) {
                throw (RuntimeException)jjte001;
              }
              if (jjte001 instanceof ParseException) {
                throw (ParseException)jjte001;
              }
              throw (Error)jjte001;
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001, true);
              }
            }
/*@egen*/         
|   t = <NUM>/*@bgen(jjtree) Num */
              {
                Num jjtn002 = new Num(JJTNUM);
                boolean jjtc002 = true;
                jjtree.openNodeScope(jjtn002);
              }
              try {
/*@egen*//*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn002, true);
                jjtc002 = false;
              }
/*@egen*/ {jjtn002.value = t.image; }/*@bgen(jjtree)*/
              } finally {
                if (jjtc002) {
                  jjtree.closeNodeScope(jjtn002, true);
                }
              }
/*@egen*/     
|   t = <TRUE>/*@bgen(jjtree) BoolOp */
               {
                 BoolOp jjtn003 = new BoolOp(JJTBOOLOP);
                 boolean jjtc003 = true;
                 jjtree.openNodeScope(jjtn003);
               }
               try {
/*@egen*//*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn003, true);
                 jjtc003 = false;
               }
/*@egen*/ {jjtn003.value = t.image; }/*@bgen(jjtree)*/
               } finally {
                 if (jjtc003) {
                   jjtree.closeNodeScope(jjtn003, true);
                 }
               }
/*@egen*/         
|   t = <FALSE>/*@bgen(jjtree) BoolOp */
                {
                  BoolOp jjtn004 = new BoolOp(JJTBOOLOP);
                  boolean jjtc004 = true;
                  jjtree.openNodeScope(jjtn004);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn004, true);
                  jjtc004 = false;
                }
/*@egen*/ {jjtn004.value = t.image; }/*@bgen(jjtree)*/
                } finally {
                  if (jjtc004) {
                    jjtree.closeNodeScope(jjtn004, true);
                  }
                }
/*@egen*/        
|/*@bgen(jjtree) FuncReturn */
    {
      FuncReturn jjtn005 = new FuncReturn(JJTFUNCRETURN);
      boolean jjtc005 = true;
      jjtree.openNodeScope(jjtn005);
    }
    try {
/*@egen*/   (t = <ID> [<LBRACKET> ArgList() <RBRACKET>]/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn005, true);
                                                  jjtc005 = false;
                                                }
/*@egen*/ {jjtn005.value = t.image;} )/*@bgen(jjtree)*/
    } catch (Throwable jjte005) {
      if (jjtc005) {
        jjtree.clearNodeScope(jjtn005);
        jjtc005 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte005 instanceof RuntimeException) {
        throw (RuntimeException)jjte005;
      }
      if (jjte005 instanceof ParseException) {
        throw (ParseException)jjte005;
      }
      throw (Error)jjte005;
    } finally {
      if (jjtc005) {
        jjtree.closeNodeScope(jjtn005, true);
      }
    }
/*@egen*/           
}

void Condition() : {}
{
    (<TILDE> Condition() Condition2())
|   LOOKAHEAD(3) <LBRACKET> Condition() <RBRACKET> Condition2()
|   (Expression() ComparisonOp() Condition2())
}

void ComparisonOp()            : {/*@bgen(jjtree) Comparison */
                                  Comparison jjtn000 = new Comparison(JJTCOMPARISON);
                                  boolean jjtc000 = true;
                                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Comparison */
    try {
/*@egen*/
    t = <EQUALS> Expression()/*@bgen(jjtree) EQComp */
                              {
                                EQComp jjtn001 = new EQComp(JJTEQCOMP);
                                boolean jjtc001 = true;
                                jjtree.openNodeScope(jjtn001);
                              }
                              try {
/*@egen*//*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn001, true);
                                jjtc001 = false;
                              }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                              } finally {
                                if (jjtc001) {
                                  jjtree.closeNodeScope(jjtn001, true);
                                }
                              }
/*@egen*/        
|   t = <NEQUALS> Expression()/*@bgen(jjtree) NEComp */
                               {
                                 NEComp jjtn002 = new NEComp(JJTNECOMP);
                                 boolean jjtc002 = true;
                                 jjtree.openNodeScope(jjtn002);
                               }
                               try {
/*@egen*//*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn002, true);
                                 jjtc002 = false;
                               }
/*@egen*/ {jjtn002.value = t.image;}/*@bgen(jjtree)*/
                               } finally {
                                 if (jjtc002) {
                                   jjtree.closeNodeScope(jjtn002, true);
                                 }
                               }
/*@egen*/        
|   t = <LT> Expression()/*@bgen(jjtree) LTComp */
                          {
                            LTComp jjtn003 = new LTComp(JJTLTCOMP);
                            boolean jjtc003 = true;
                            jjtree.openNodeScope(jjtn003);
                          }
                          try {
/*@egen*//*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn003, true);
                            jjtc003 = false;
                          }
/*@egen*/ {jjtn003.value = t.image;}/*@bgen(jjtree)*/
                          } finally {
                            if (jjtc003) {
                              jjtree.closeNodeScope(jjtn003, true);
                            }
                          }
/*@egen*/        
|   t = <LE> Expression()/*@bgen(jjtree) LEComp */
                          {
                            LEComp jjtn004 = new LEComp(JJTLECOMP);
                            boolean jjtc004 = true;
                            jjtree.openNodeScope(jjtn004);
                          }
                          try {
/*@egen*//*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn004, true);
                            jjtc004 = false;
                          }
/*@egen*/ {jjtn004.value = t.image;}/*@bgen(jjtree)*/
                          } finally {
                            if (jjtc004) {
                              jjtree.closeNodeScope(jjtn004, true);
                            }
                          }
/*@egen*/        
|   t = <GT> Expression()/*@bgen(jjtree) GTComp */
                          {
                            GTComp jjtn005 = new GTComp(JJTGTCOMP);
                            boolean jjtc005 = true;
                            jjtree.openNodeScope(jjtn005);
                          }
                          try {
/*@egen*//*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn005, true);
                            jjtc005 = false;
                          }
/*@egen*/ {jjtn005.value = t.image;}/*@bgen(jjtree)*/
                          } finally {
                            if (jjtc005) {
                              jjtree.closeNodeScope(jjtn005, true);
                            }
                          }
/*@egen*/        
|   t = <GE> Expression()/*@bgen(jjtree) GEComp */
                          {
                            GEComp jjtn006 = new GEComp(JJTGECOMP);
                            boolean jjtc006 = true;
                            jjtree.openNodeScope(jjtn006);
                          }
                          try {
/*@egen*//*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn006, true);
                            jjtc006 = false;
                          }
/*@egen*/ {jjtn006.value = t.image;}/*@bgen(jjtree)*/
                          } finally {
                            if (jjtc006) {
                              jjtree.closeNodeScope(jjtn006, true);
                            }
                          }
/*@egen*/        /*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Condition2() : {Token t;}
{
    t = <OR> Condition()/*@bgen(jjtree) ORCondition */
                         {
                           ORCondition jjtn001 = new ORCondition(JJTORCONDITION);
                           boolean jjtc001 = true;
                           jjtree.openNodeScope(jjtn001);
                         }
                         try {
/*@egen*//*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn001, true);
                           jjtc001 = false;
                         }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                         } finally {
                           if (jjtc001) {
                             jjtree.closeNodeScope(jjtn001, true);
                           }
                         }
/*@egen*/             
|   t = <AND> Condition()/*@bgen(jjtree) ANDCondition */
                          {
                            ANDCondition jjtn002 = new ANDCondition(JJTANDCONDITION);
                            boolean jjtc002 = true;
                            jjtree.openNodeScope(jjtn002);
                          }
                          try {
/*@egen*//*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn002, true);
                            jjtc002 = false;
                          }
/*@egen*/ {jjtn002.value = t.image;}/*@bgen(jjtree)*/
                          } finally {
                            if (jjtc002) {
                              jjtree.closeNodeScope(jjtn002, true);
                            }
                          }
/*@egen*/              
|   {}
}

void ArgList()          : {/*@bgen(jjtree) ArgList */
  ArgList jjtn000 = new ArgList(JJTARGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArgList */
    try {
/*@egen*/
    [NonEmptyArgList()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NonEmptyArgList() : {}
{
    Identifier() [<COMMA> NonEmptyArgList()]
}
